# 
##  1장 협력하는 객체들의 공동체
   - [ ] 인간의 세계에선 역할, 책임, 협력이 있다 -> 객체의 세계에서도 마찬가지
   - [ ] 협력 공동체의 일원으로서 객체는 다음 두 가지 덕목을 갖춰야한다
   - 1. 객체는 충분히 협력적이어야한다.
     2. 객체는 자율적이어야한다. -> 객체의 자율성을 갖기 위해선 행동과 상태를 지니고 있어야하며  내부와 외부를 명확하게 구분하는 것으로부터 나온다.
     객체는 다른 객체가 '무엇'을 수행하는지는 알 수 있지만 '어떻게' 수행하는지에 대해선 알 수 없다.
     과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분 But 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 묶어놓음으로
     객체의 자율성을 보장한다. -> 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시
   - [ ] 객체지향의 세계에서는 한 가지 의사소통 수단이 존재한다 = 메시지, 객체가 수신한 메시지를 처리하는 방법을 메서드라고 부른다 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 점은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 
     (프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징)
     많은 사람들은 객체지향 프로그래밍 언어를 이야기할 때 클래스를 정의하는 방법과 클래스 사이의 상속에 초점을 맞춘다
     but 클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 분명, 중심 개념이라고 말하기에는 무리가 있다.
     ex) 자바 스크립트같은 객체지향 언어에서는 클래스가 존재하지 않으며 오직 객체만이 존재한다. 
     훌룡한 객체지향 설계자가 되기 위해선...
     클래스의 관점에서 메시지를 주고 받는 객체의 관점으로 사고의 중심을 전환하는 것이다.
## 2장 이상한 나라의 객체
   - [ ] 엘리스의 상태를 결정하는 것은 행동, 행동의 결과를 결정하는 것은 상태이다. (엘리스의 기존 키:상태, 엘리스가 최종 키를 바꾸기 위해 먹거나,부채질: 행동)
   - [ ] 엘리스의 상태 변경과 무관하게 엘리스는 유일한 존재로 "식별 가능"하다 
   ### 객체란 식별 가능한 객체 또는 사물이다.
   #### 객체는 상태, 행동, 식별자를 지닌 실체이다.
   - 1. 상태: 어떤 행동의 결과는 과거에 어떤 행동들이 일어났느냐에 의존한다. 하지만 과거에 어떤 행동들이 있어났는지 모두 다 기억하는 것은 어렵다. 그렇기에 행동의 과정과 결과를
     단순하게 기술하기 위해 상태라는 개념이 나왔다. 
       객체의 상태는 단순한 값과, 객체의 조합으로 표현할 수 있다. 이 특징들을 객체의 "프로퍼티"라고 한다. 일반적으로 "프로퍼티"는 정적이다. 하지만
       "프로퍼티의 값"은 변경되기 쉽기에 동적이다. (엘리스의 키: 프로퍼티 ,150cm: 프로퍼티 값)
       객체와 객체 사이의 의미 있는 연결을 "링크"라고 한다. 링크가 존재해야만 요청을 보내고 받을 수 있다.
       링크가 없다면 다른 객체를 참조할 수 없다.!
       객체의 프로퍼티중 링크와 달리 객체를 구성하는 단순한 값은 "속성"이라고 한다(엘리스의 키), 링크는 엘리스가 들고 있는 음료수라고 표현할 수 있다. 물론 둘 다 프로펄티이다.
       -> 상태는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.
       객체는 자율성을 가지고 있기에 객체가 외부의 객체의 상태를 주무를 수 없다-> 행동으로 간접적으로 객체의 상태를 변경하는 것이 가능하다. 
     #### 객체는 스스로의 행동의 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다
   - 2. 행동: 행동은 상태에 영향을 받는다, 행동은 상태를 변경시킨다
      - [ ] 행동으로 발생하는 결과 -> 1)객체 자신의 상태변경 2) 행동 내에서 협력하는 다른 객체에 메시지 전송
      - [ ] 캡슐화
       객체의 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 오로지 행동만을 노출한다.  행동을 유발하는 것은 메시지이지만 상태를 변경할지 여부는 객체 스스로다.
   - 3. 식별자: 객체는 식별자를 가지지만 단순한 값은 식별자를 가지지 않는다.
       상태를 이용해 같은지 비교(값),식별자를 이용해 같은지 비교(객체) Integer,Person 둘 다 java에선 객체기때문에 헷갈릴 수 있다.
       하지만 키를 Integer로 표현한다면 그건 객체가 아니라 값이다.
     #### 행동이 상태를 결정한다
   - [ ] 협력을 생각-> 협력에 필요한 행동을 생각-> 행동을 수행하는 객체 선택. 행동을 결정하고 이후에 필요한 정보를 고려하여 상태를 결정
     #### 은유와 객체
   - [ ] 소프트웨어 상품은 실제 세계의 상품을 단순히 추상화한 것이 아니라 특성이 전혀 다르다.
   - [ ] 의인화
       현실에서는 수동적 존재가 소프트웨어 세상에서는 능동적으로 변한다(음료수가 스스로 양조절) -> 더욱 많은 특징과 능력보유-> 객체지향의 세계는 현실의 추상화가 아니다.
## 3장 타입과 추상화
### 추상화는 현실에서 출발하되 불필요한 부분을 도려내어 복잡성을 줄이고 본질을 드러내는 과정.
추상화는 "목적"에 의존적이다. 현상은 복잡 법칙은 단순하니 버릴게 무엇인지 알아내라
### 객체지향과 추상화
구체적인 사물간의 차이점을 무시하고 공통점만을 취해 특정개념으로 단순화하는 것은 추상화의 일종이다. 이후 남은 공통점에서 불필요한 세부 사항은 제거
  많은 객체중 특정 특징을 가지고 있는 객체만을 특정 "개념(트럼프)"으로 추상화.그리고 개념에 속한 객체를 개념의 인스턴스라고 한다. 개념에 따라 우리는 객체들을 분류한다.
### 타입
- [ ] 타입은 개념이다
1. 타입은 데이터가 어떻게 사용되느냐에 관한 것이다(숫자형 데이터는 사칙연산, 문자열은 합쳐문자열을 만들거나 문자의 길이를 알 수 있음)
  즉 데이터가 어떤 타입에 속하는지 결정하는 것은 데이터에 적용할 수 있는 작업(연산자)
2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 개발자는 단순히 데이터 타입에 적용할 수 있는 연산자만 알고 있으면 된다.
- [ ] 객체와 타입
1. 실제로 프로그래밍을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다.
2. 그렇다면 객체는 데이터인가? 그렇지 않다. 객체에서 중요한 것은 "상태"가 아닌 행동이다.객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야할 지 결정하는 것이 중요하다
.데이터 타입은 객체의 타입과도 동일하게 적용된다.  
첫째, 어떤 객체가 어떤 타입에 속하는지 결정하는 것은 객체가 수행하는 행동이다. 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.  
둘쨰, 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다  
여기서 우리는 중요한 원칙을 이끌어낼 수 있다. 바로 " 행동이 우선이다" 라는 것이다.
첫번째에 따르면 어떤 행동을 하느냐에 따라 객체의 타입이 결정된다. 두번째에 따르면 객체의 타입은 객체의 내부 표현과는 아무 상관이 없다. 따라서 
* 내부 표현이 다르더라도 어떤 객체가 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다. 동일한 책임을 수행하는 객체는 동일한 타입에 속한다고 할 수 있다.  
* 내부의 표현이 달라도 동일하나 메시지를 수신하고 이를 처리한다면 같은 타입이다. 하지만 표현 방식이 다르다면 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.
* 이것은 "다형성"에 의미를 부여한다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력이다.  
* 또한 내부 표현방식과 무관하게 행동만이 고려 대상이라는 사실은, 행동만을 보여주고 데이터를 감춰야한다. 이 원칙을 흔히 캡슐화라고 한다. 
즉 행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야하는 데이터가 아니라 객체가 외부에 제공하야 하는 행동을 먼저 생각해야한다.   
그렇다면 책임을 먼저 결정하고 이후에 데이터를 결정한 후 데이터를 외부 인터페이스 뒤로 캡슐화해야한다. 이것이 바로 "책임-주도-설계"이다.
### 타입의 계층
1. 슈퍼타입과 서브 타입또한 두 타입간의 관계가 행동에 의해 결정된다는 것을 알아야한다. 즉 특정 타입이 다른 타입의 서브 타입이 되기 위해서는 행위적 호환성을 만족시켜야한다.  
ex) 트럼프인간은 트럼프를 대체할 수 있어야한다. 
### 정적 모델
- [ ] 타입의 목적  
왜 타입을 사용해야할까? 사용하는 이유는 인간의 인지능력으로는 객체의 복잡성을 극복하기가 너무 어렵기 떄문이다.  
타입은 시간에 따라 동적으로 변하는 엘리스의 상태를 시관과 무관한 정적인 모습으로 다룰 수 있게해준다.
-[ ] 그렇기에 결국 타입은 추상화다.  
어떤 시점에 엘리스에 관해 생각할 때 불필요한 시간과 상태변화라는 요소를 제거하고 철저하게 정적인 관점에서 엘리스의 모습을 묘사하는 것을 가능케해준다.  
타입은 추상화이기 때문에 타입을 이요한다면 객체의 동적인 특성을 추상화 할 수 있다.  
-[ ] 클래스  
객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 타입을 구현하는 가장 보편적인 방법은 클래스라는 것이다. "타입을 구현한다"에 주의해야한다  
클래스와 타입은 동일한 것이 아니다! 타입은 객체를 분류하기 위해 사용되는 개념이다. 클래스는 타입을 구현할 수 있는 메커니즘 중 하나일 뿐이다. (자바 스크립트에 클래스가 존재하지 않음)  
하지만 객체지향 패러다임을 주도하는 대부분의 프로그래밍 언어는 클래스를 기반으로 하기 때문에 대부분의 사람들은 클래스와 타입을 동일한 개념이라고 생각한다.  
클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 구분하여야한다. 
## 4장 역할, 책임, 협력
### 협력
- [ ] 요청하고 응답하며 협력하는 사람들  
"협력"은 한 사람이 다른 사람에게 도움을 "요청"할 때 시작된다. 그리고 그 요청에 응답한다  
특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는데 필요한 지식과 행동 방식을 가지고 있기 때문이다.
### 책임  
오떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나 적절한 행동을 할 의무가 있는 경우 해당 객체가 "책임"을 가진다고 말한다. 즉 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시한다.  
객체지향 개발에서 가장 중요한 능력은 책임을 객체에 할당하는 것이다. 어떻게 구현할 것인가 하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지않다.
- [ ] 책임의 분류  
책임은 객체에 정의되는 응집도 있는 행위의 집합이다. 즉 책임은 객체가 무엇을 알고있는가와, 무엇을 할 수 있는가로 구성된다.  
책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것)과 외부에 제공해 줄 수 있는 서비스(하는 것)의 목록이다. 즉 책임은 객체의 공용 인터페이스를 구성한다.
- [ ] 책임과 메시지  
객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 "메시지 전송" 이라고 한다. 두 객체간의 협력은 메시지를 통해 이뤄진다. 메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 방법이다!!  
설계를 시작하는 초반에는 객체가 어떤 책임을 가지고 어떤 방식으로 서로 협력해야 하는지에 대한 개요를 아는 것만으로도 충분하다.  
객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야하고 어떤 객체로부터 메시지를 수신할 것인지 결정하는 것으로부터 시작된다. 어떤 클래스, 어떤 메서드를 포함해야하는지는 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.!  
### 역할
- [ ] 책임의 집합이 의미하는 것 
역할이란것은 왜 중요할까? 굳이 책임의 집합을 특정 역할을 붙혀서 상황을 복잡하게 만드는 이유가 뭔가? 그건 바로 역할은 재사용이 가능하기 때문이다.  
역할을 사용한다면 다양한 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화 할 수 있다. 협력 안에서의 역할은 "이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있다"라고 말하는 것과 같다.  
동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기에 동일한 책임을 수행할 수 있다는 것이다.!! 역할의 개념을 사용하여 협력을 추상화해서 다양한 객체들이 협력에 참여할 수 있기 때문에 재사용성이 높아진다.
- 역할은 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.
- [ ] 협력의 추상화  
역할의 가장 큰 가치는 하나의 협력 안에서 여러 종류의 객체가 참여할 수 있게 함으로 협력을 "추상화" 할 수 있다는 것이다. 
- [ ] 대체 가능성  
본질적으로 역할은 다른 객체에 의해 대체 가능함을 의미한다. 객체가 역할을 대체하기 위해서는 행동이 호환되어야한다. 객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목해야한다. (모자 장수는 증인+ 모자장수로의 책임을 가지고 있다)  
결국 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. 즉 객체의 타입과 역할 사이에는 일반화/특수화 관계가 성립한다.  
요약하자면 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.
### 객체의 모양을 결정하는 협력  
- [ ] 흔한 오류  
많은 사람들은 데이터를 저장하기 위해 객체가 존재한다는 선입견을 가지고 있다. 하지만 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일 뿐이다. 실제로 중요한 것은 객체의 행동, 즉 책임이다.
또한 선입견은 객체지향을 클래스와 클래스간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 것이다.  
하지만 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적이 객체이며 클래스는 단지 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 메커니즘일 뿐이다!  
클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지 결정하는 것이다.  
데이터나 클래스를 중심으로 애플리케이션을 설계하는 이유는 협력 문맥을 고려하지 않고 객체를 "독립적"으로 바라보기 때문이다. ex)왕의 근엄하고 왕자의 앉아있는 모습은 엘리스의 이야기에 어울리지 않는다.  
엘리스 이야기에서 왕이 중요한 이유는 재판이라는 협력에 "판사"의 역할로 참여해서 죄인의 죄를 판결하는 책임을 수행할 수 있기 때문이다.
- [ ] 협력을 따라 하르는 객체의 책임  
올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 설계해야한다.  
협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정하는 것을 의미한다.  
객체에게 책임을 할당하고나면 책임은 객체가 외부에 제공하게 될 행동이 된다. 협력이라는 문맥에서 객체가 수행해야할 책임, 행동을 수행하는데 필요한 데이터를 고민해야한다.  
그리고 협력에 참여하기 위해 필요한 데이터와 행동이 어느정도 결정된 후에 클래스 구현 방법을 결정하는 것이다.  
각 객체가 가져야하는 상태와 행위에 대해 고민하기 전에 그 객체가 참여할 문맥인 협력을 정의하여야한다.
### 객체지향 설계 기법
1) 책임 주도 설계  
협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식이다.  개별적인 객체의 상태가 아닌 객체의 책임과 상호작용에 집중한다.  
협조적이고 성실한 객체 시민들로 구성된 객체지향을 설계하는 절차는 다음과 같다.
- 시스템 책임을 파악한다
- 책임을 더 작은 책임으로 분할한다
- 책임을 수행할 수 있는 객체를 찾아 책임을 할당한다
- 책임 수행할 때 다른 역할의 도움이 필요한 경우 적절한 역할를 찾는다
- 책임을 할당함으로 역할들을 협력시킨다.
2) 디자인 패턴  
전문가들이 반복적으로 사용하는 해결방법을 정의해놓은 설계 템플릿의 모음이다. 역할,책임,협력이 디자인 패턴 안에 이미 존재한다.  
유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물이자 지름길이라고 할 수 있다.(MVC패턴)
3) 테스트-주도 개발  
테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성하는 것이다.  여기서 핵심은 테스트 작성이 아니라, 실제 목적은 구체적인 코드를 작성해나가며 역할,책임,협력을 식별하고 피드백을 받는 것이다.

## 5장 책임과 메시지
### 자율적인 책임
- [ ] 설계의 품질을 좌우하는 책임  
자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 책임을 수행하는 객체이다. 적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다.
- [ ] 자신의 의지에 따라 증언할 수 있는 자유  
객체가 책임을 자율적으로 수행하기 위해선 책임이 자율적이여야한다.  
"증언하라"는 모자 장수에게 어떻게 증언하는지 자유롭게 선택하도록 허용한다. 하지만, 목격했던 장면을 떠올려라, 말로 간결하게 표현하라 등등의 책임을 모자장수에게 표현하는 것은 지나치게 제한한다.  
상세한 수준의 책임은 증언이라는 협력의 최종 목표는 만족시키더라도 모자 장수가 누려야하는 선태그이 자유를 크게 훼손한다. 이 경우에 모자장수는 자율적으로 책임을 수행하기 힘들다.
- [ ] 너무 추상적인 책임  
구체적인 책임부여가 자율성을 해칠 수 있지만 그렇다고 너무 추상적인 "설명하라" 는 협력의 의도를 명확하게 표현하지 못한다.
- [ ] 어떻게가 아니라 무엇을 해야하는지를 부여하라
### 메시지와 메서드
- [ ] 메시지  
메시지 전송은 수신자와 메시지이름의 조합이다. 또한 메시지에 인자가 들어갈 수 있다 (모자장수.증언하라(어제,왕국))
- [ ] 다형성  
다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것이다. 즉 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 것이다.  
메시지를 어떻게 실행할 것인지는 전적으로 수시자가 결정할 수 있다. 따라서 다형성을 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있다. "증언하라" 는 엘ㄹㅣ스,모자장수,요리사에 따라 다르다.  
서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것이다! 그리고 이것은 대체 가능성을 의미한다. 이 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만든다.  
다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. 즉, 다형성은 수신자의 종류를 캡슐화한다.  
다형성은 송신자와 수신자간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다.  
이 다형성이야말로 협력을 유연하게 만들어 객체지향이 유연하고 확장 가능하고 재사용성이 높다은 무기가 된다. 
- [ ] 유연하고 확장 가능하고 재사용성이 높은 협력의 의미  
왕은 수신자의 구체적인 타입에 대해서는 알지 못한다. 즉 왕은 수신자가 메시지를 수신할 수만 있다면 누가 되어도 상관하지 않는다.  
그리고 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다
1) 협력이 유연해진다. 수신자를 다른 타입의 객체로 대체하더라도 송신자는 알지 못한다. 즉 송신자에 대한 파급효과 없이 유연하게 협력을 변경할 수 있다
2) 협력이 수행되는 방식을 확장할 수 있다. "증언하라"라는 메시지를 기반으로 느슨한 관계만 존재하기 때문에 재판장에 출석하지 않고 동영상만 보내는 객체라도 책임만 완수할 수 있다면 쉽게 수용할 수이따.  
3) 협력이 수행되는 방식을 재사용할 수 있다. 협력에 영향을 미치지 않고서도 다향한 객체들이 수신자의 자리를 대체할 수 있기떄문에 협력을 재사용할 수 있다!!
- [ ] 송신자와 수신자를 약하게 연결하는 메시지  
메시지는 송신자, 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만든다.  
송신자는 메시지만 바라본다. 수신자의 정확한 타입을 모른다  
수신자와 송신자는 메시지라는 얇은 끈으로만 이어져있다. 이 낮은 결합도가 바로 설계를 유연하고 확장 가능하며 재사용 가능하게 만드는 비결이다  
### 메시지를 따라라
- [ ] 객체지향의 핵심, 메시지  
클래스 기반의 객체지향 언어를 사용하는 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각한다. 그리고 클래스를 선언하고 속성과 메서드를 정의하는 방법에 초점을 맞춘다. 그리고 상속이 객체지향 설계를 가치있게 만드는 메커니즘이라고 한다.  
클래스가 중요한 추상화도구인 것은 사실이지만 !객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지! 에서 나온다.  
클래스가 아니라 객체가 애플리케이션을 살아있게 만들고 메시지가 이런 객체들의 윤곽을 결정한다.  클래스를 사용하지 않고도 객체의 속성과 행위를 표현할 수도 있다!  
클래스에 담길 객체들의 공통적인 행위와 속성을 포착하기 위해서는 먼저 협력하는 객체들의 관점에서 시스템을 바라보아야한다.  
메시지가 아니라 데이터를 중심으로 객체를 설계하는 방식은 객체 내부 구조를 객체 정의 일부로 만들기에 자율성을 저해한다. 내부 구조는 감춰져야한다.  
데이터에 대한 결정을 뒤로 미루고 행위를 고려하기 위해서는 객체를 독립적인 단위가 아니라 협력이라는 문맥 안에서 생각해야한다! 그러기 위해선 독립된 객체의 상태와 행위보다 메시지에 대해 먼저 고민하라  
훌룡한 객체지향설계는 어떤 메시지를 전송할 수 있고 어떤 메시지를 수신할 수 있는가에서 시작이지, 개별 객체에 초점을 맞추면 안 된다.  
- 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야한다. 
- [ ] 책임 주도 설계 다시 살펴보기  
객체가 책임을 완수하기 위해 다른 객체의 도움이 필요하다고 판단되면 도움을 요청하기 위해 어떤 메시지가 필요한지 결정한다. 메시지를 결정한 후에 메시지를 수신하기에 적합한 객체를 선택한다.  
결과적으로 메시지가 수신자의 책임을 결정하는 것이다.  
묻지 말고 시켜라 스타일로 객체를 자율적으로 만들고 캡슐화를 보장하며, 결합도를 낮게 유지시켜 주기 떄문에 설계를 유연하게 만든다.  
객체가 자신이 수신할 메시지를 결정하게 하지말고, 메시지가 협력에 필요한 객체를 발견하도록 해야한다!!
### 메시지를 믿어라  
다형성은 개별객체가 아닌 객체들이 주고받는 메시지에 초점을 맞출 때 비로소 그 진가를 발휘한다. 메시지를 믿어라! 그렇다면 자율적인 책임은 저절로 따라올 것이다.
### 객체 인터페이스 
- [ ] 인터페이스  
인터페이스란 어떤 두 사물이 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다. 그리고 인터페이스는 다음과 같은 특징을 지닌다
1) 사용법만 익히면 내부구조나 동작방식을 몰라도 된다.
2) 내부구조나 동작방식을 변경하는 것은 사용자에게 어떤 영향도 끼치지 않는다.
3) 대상이 변경되더라도 동일한 인터페이스를 제공하면 아무런 문제 없이 상호작용 할 수 있다.  
- [ ] 메시지가 인터페이스를 결정한다  
객체의  인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며, 어떤 메시지를 수신할 수 있는지가 인터페이스의 모양을 빚는다.  
인터페이스는 객체가 외부로부터 메시지를 받기 위한 통로이다.  
메시지로 구성된 공용 인터페이스는 객체의 외부와 내부를 명확하게 분리한다;
### 인터페이스와 구현의 분리
객체지향의 세계에서 내부 구조와 작동방식을 가리키는 고융의 용어는 구현이다. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현이다. (ex, 상태, 메서드를 구성하는 코드 자체)
- [ ] 인터페이스와 구현의 분리 원칙  
훌룡한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 그렇다면 구현의 분리가 중요할까?  
그것은 소프트웨어는 항상 변경되기 때문이다. 어떤 객체를 수정했을 때 어떤 객체가 영향을 받는지를 판단하는 것은 매우 어렵다. 객체의 다양한 부분이 외부에 공개돼 있다면 작은 부분을 수정하여도 변경에 의한 파급효과가 객체 공동체의 구석구석까지 파고들 것이다.  
객체가 가져야할 상태와 메서드 구현은 객체 내부에 속한다!  이부분을 수정할 때 객체 외부에 영향을 끼쳐선 안된다/
- [ ] 캡슐화  
구현을 외부로부터 감추는 것을 캡슐화라고 한다. 
1) 상태와 행동을 숨기는 것은 데이터 캡슐화라고 한다. 
2) 사적인 비밀의 캡슐화. 객체를 자율적인 존재로 바라보는 것은 결국 객체의 내부와 외부를 엄격하게 분리한다는 것을 의미한다. 객체는 자신의 의지에 따라 변경하고 조작할 수 있는 비밀을 가지고있다. 이것이 객체의 내부다!  
객체지향이 유연하고 재사용 가능하다고 알려진 이유는 내부와 외부를 명확하게 구분하기 때문이다.
- [ ] 책임의 자율성이 협력의 품질을 결정한다.
1) 자율적인 책임은 협력을 단순하게 만든다. ex) 증언하다 and 어떠어떠하게 하고 어떻게 표현하라 ->책임이 적절하게 추상화된다
2) 자율적인 책임은 외부와 내부를 명확하게 분리한다. ex) 어떤 방식으로 선택할지는 모자 장수의 권한이다. 그리고 왕은 어떻게 모자장수가 책임을 수행하는지 모른다
3) 책임이 자율적인 경우 내부적인 것을 변경해도 외부에 영향을 끼치지 않는다. 모자장수가 증언하는 방식을 변경할지라도 협력은 무너지지 않는다.  
책임이 자율적일수록 변경에 의해 수정돼야하는 범위가 좁아지고 명확해진다 ex) 모격했던 장면 떠올려라-> 메모한 것 참조해라로 바꾸면 왕과 모자장수 둘 다 수정해야한다  
변경의 파급효과를 캡슐화하여 두객체간의 결합도를 낮춰야한다
4) 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.ex)메모한 것이 없는 증언자라면.... (인자가 어떤 것인지에 따라 서로 다른 메서드를 실행하는 것을 결정하는 것은 책임을 수행하는 객체자신이다(if(~~equals)) )
5) 자율적일 수록 객체의 역할을 이해하기 쉬워진다. ex)메모한 것을 참조해라로 명령한다면 왕이 증언 방식을 선택하는 증인의 책임을 어느정도가지고 역할도 어느정도 분담하는 것처럼 느껴진다. 
## 객체 지도
### 기능 설계 vs 구조 설계 
기능 측면의 설계는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다. 구조 측면의 설계는 제품의 형태가 어떠해야하는지에 초점을 맞춘다. 
### 안정적인 재료:구조
도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.  
- [ ] 도메인의 모습을 담을 수 있는 객체지향  
최종코드는 사용자가 도메인을 바라보는 관점을 반영해야한다.  
- [ ] 표현적 차이  
소프트웨어 객체는 현실 객체에 대한 추상화가 아닌다. 우리는 추상화가 아니라 은유로 재창조하는 것이다. 그렇기에 소프트웨어 객체는 현실 객체가 갖지 못한 특성을 가질 수 있고 객체가 하지 못 하는 행동을 할 수 있다.  
도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것이다.  
### 불안정한 재료:기능  
유스케이스는 시스템의 이해관계자들 간의 계약을 행위 중심으로 파악한다. 
- [ ] 유스케이스의 특성
1) 유스케이스는 사용자와 시스템간의 상호작용을 보여주는 '텍스트'이다.(다이어 그램이 아니다)
2) 유스케이스는 하나의 시나리오가 아니라 여러 시나리오의 계산이다. 
3) 유스케이스는 단순 기능 목록과는 아니다. 단순한 기능을 나열하는 것이 아닌 이야기를 통해 연관된 기능을 하나로 묶는다
4) 유스케이스는 인터페이스와 관련된 세부 정보를 포함하지 말아야한다. 
5) 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.
### 재료합치기: 기능과 구조의 통합
- [ ] 도메인,유스케이스,그리고 책임-주도 설계  
도메인 모델은 안정적인 구조를 개념화하기 위해, 유스케이스는 기능을 서술하기 위해 사용되는 도구이다.  
시스템에 할당된 책임이 이제 시스템안의 작은 규모의 객체들이 수행해야하는 더 작은 규모의 책임으로 세분화된다. 그렇다면 어떤 객체를 선택할 것인가? 이 시점에서 도메인 모델이 무대에 등장한다.
![IMG_4671.png](IMG_4671.png)  
협력을 완성하는데 필요한 메시지를 식별하면서 객체들에게 책임을 할당한다. 그리고 객체를 구현하기 위해 클래스를 추가하고 속성과함께 메서드를 구현한다. 그러면 코드는 기능을 수용할 수 있는 안정적인 구조에 기반한다.  
유스케이스는 사용자에게 제공할 기능을 책임으로 보게 함으로 구조에 책임을 분배할 수 있는 출발점을 제공한다. 도메인 모델을 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다.  
- 책임-주도 설계 방법은 기능을 역할과 책임을 수행하는 객체들의 협력관계를 바로보게 함으로 유스케이스와 도메인 모델을 통합한다.  
중요한 것은 사용자의 관점에서 기능을 명시하고, 구조를 기반으로 기능을 책임으로 변환하는 절차를 거쳐야한다.  
책임 할당의 기본 원칙은 책임을 수행하는데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것이다! 그렇기에 이자를 계산하는 책임을 이자율 객체에 할당한다.  
- [ ] 기능 변경을 흡수하는 안정적인 구조  
도메인 모델이 안정적인 이유는 도메인 모델을 구성하는 요소가 다음과 같은 특징을 띄기 때문이다
1) 도메인 모델을 구성하는 개념은 완전히 개편되지 않는한 유지된다(정기예금,계좌,이자율,이자)
2) 개념간의 관계또한 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지된다.  
이자율 계산 방법이 바뀐다고 할 때,(단리 이자 규칙, 복리 이자 규칙) 이자율만 상속으로 변경함으로 핵심적인 클래스와 클래스 간의 관계는 그대로 유지시킬 수 있다.  
안정적인 도메인 모델을 기반으로 시스템의 기능을 구현할 경우 시스템의 기능이 변경되더라도 핵심 정책이나 규칙이 변경되지 않는 한 전체적인 구조가 흔들리진 않는다.  
이것이 객체지향이 기능의 변경에 대해 좀 더 유연하게 대응할 수 있는 패러다임이라고 일컬어지는 이유다.  
도메인 모델은 문서나 다이어그램이 아니다. 도메인 모델은 사람들의 머릿속에 들어있는 멘탈 모델이다. 

## 함께 모으기
객체지향 설계의 첫번쨰 목표는 훌룡한 객체를 설계하는 것이 아니라 훌룡한 협력을 설계하는 것이다. 메시지가 객체를 선택하도록 하자.  
또한 객체가 수신한 메시지가 객체의 인터페이스를 결정한다는 사실을 기억하여라. 메시지가 객체(커피, 바리스타, 손님)를 선택하고, 선택된 객체는 자신의 메시지를 자신의 인터페이스로 받아들인다.  
- 객체의 속성은 객체의 내부 구현에 속하기 때문에 캡슐화되어야한다. 이를 위한 가장 훌룡한 방법은 인터페이스를 정하는 단계에서는 객체가 어떤 속성을 가지는지 또 속성이 어떤 자료구조로 구햔됐는지 고려하지 않는 것이다. 어떤 책임을 수행하는지를 결정하고 책임을 수행하는데 필요한 속성을 결정하여라.
- [ ] 인터페이스와 구현을 분리하라  
명세관점(공용 인터페이스) 와 구현관점을 명확히 구분하여야한다. 인터페이스가 구현 세부 사항을 노출하기 시작하면 작은 변동에도 전체 협력이 요동치게 된다.  
중요한 것은 클래스를 봤을 때 클래스를 명세,구현 관점으로 나눠볼 수 있어야한다. 
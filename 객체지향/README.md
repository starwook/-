# 
##  1장 협력하는 객체들의 공동체
   - [ ] 인간의 세계에선 역할, 책임, 협력이 있다 -> 객체의 세계에서도 마찬가지
   - [ ] 협력 공동체의 일원으로서 객체는 다음 두 가지 덕목을 갖춰야한다
   - 1. 객체는 충분히 협력적이어야한다.
     2. 객체는 자율적이어야한다. -> 객체의 자율성을 갖기 위해선 행동과 상태를 지니고 있어야하며  내부와 외부를 명확하게 구분하는 것으로부터 나온다.
     객체는 다른 객체가 '무엇'을 수행하는지는 알 수 있지만 '어떻게' 수행하는지에 대해선 알 수 없다.
     과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분 But 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 묶어놓음으로
     객체의 자율성을 보장한다. -> 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시
   - [ ] 객체지향의 세계에서는 한 가지 의사소통 수단이 존재한다 = 메시지, 객체가 수신한 메시지를 처리하는 방법을 메서드라고 부른다 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 점은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 
     (프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징)
     많은 사람들은 객체지향 프로그래밍 언어를 이야기할 때 클래스를 정의하는 방법과 클래스 사이의 상속에 초점을 맞춘다
     but 클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 분명, 중심 개념이라고 말하기에는 무리가 있다.
     ex) 자바 스크립트같은 객체지향 언어에서는 클래스가 존재하지 않으며 오직 객체만이 존재한다. 
     훌룡한 객체지향 설계자가 되기 위해선...
     클래스의 관점에서 메시지를 주고 받는 객체의 관점으로 사고의 중심을 전환하는 것이다.
## 2장 이상한 나라의 객체
   - [ ] 엘리스의 상태를 결정하는 것은 행동, 행동의 결과를 결정하는 것은 상태이다. (엘리스의 기존 키:상태, 엘리스가 최종 키를 바꾸기 위해 먹거나,부채질: 행동)
   - [ ] 엘리스의 상태 변경과 무관하게 엘리스는 유일한 존재로 "식별 가능"하다 
   ### 객체란 식별 가능한 객체 또는 사물이다.
   #### 객체는 상태, 행동, 식별자를 지닌 실체이다.
   - 1. 상태: 어떤 행동의 결과는 과거에 어떤 행동들이 일어났느냐에 의존한다. 하지만 과거에 어떤 행동들이 있어났는지 모두 다 기억하는 것은 어렵다. 그렇기에 행동의 과정과 결과를
     단순하게 기술하기 위해 상태라는 개념이 나왔다. 
       객체의 상태는 단순한 값과, 객체의 조합으로 표현할 수 있다. 이 특징들을 객체의 "프로퍼티"라고 한다. 일반적으로 "프로퍼티"는 정적이다. 하지만
       "프로퍼티의 값"은 변경되기 쉽기에 동적이다. (엘리스의 키: 프로퍼티 ,150cm: 프로퍼티 값)
       객체와 객체 사이의 의미 있는 연결을 "링크"라고 한다. 링크가 존재해야만 요청을 보내고 받을 수 있다.
       링크가 없다면 다른 객체를 참조할 수 없다.!
       객체의 프로퍼티중 링크와 달리 객체를 구성하는 단순한 값은 "속성"이라고 한다(엘리스의 키), 링크는 엘리스가 들고 있는 음료수라고 표현할 수 있다. 물론 둘 다 프로펄티이다.
       -> 상태는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.
       객체는 자율성을 가지고 있기에 객체가 외부의 객체의 상태를 주무를 수 없다-> 행동으로 간접적으로 객체의 상태를 변경하는 것이 가능하다. 
     #### 객체는 스스로의 행동의 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다
   - 2. 행동: 행동은 상태에 영향을 받는다, 행동은 상태를 변경시킨다
      - [ ] 행동으로 발생하는 결과 -> 1)객체 자신의 상태변경 2) 행동 내에서 협력하는 다른 객체에 메시지 전송
      - [ ] 캡슐화
       객체의 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 오로지 행동만을 노출한다.  행동을 유발하는 것은 메시지이지만 상태를 변경할지 여부는 객체 스스로다.
   - 3. 식별자: 객체는 식별자를 가지지만 단순한 값은 식별자를 가지지 않는다.
       상태를 이용해 같은지 비교(값),식별자를 이용해 같은지 비교(객체) Integer,Person 둘 다 java에선 객체기때문에 헷갈릴 수 있다.
       하지만 키를 Integer로 표현한다면 그건 객체가 아니라 값이다.
     #### 행동이 상태를 결정한다
   - [ ] 협력을 생각-> 협력에 필요한 행동을 생각-> 행동을 수행하는 객체 선택. 행동을 결정하고 이후에 필요한 정보를 고려하여 상태를 결정
     #### 은유와 객체
   - [ ] 소프트웨어 상품은 실제 세계의 상품을 단순히 추상화한 것이 아니라 특성이 전혀 다르다.
   - [ ] 의인화
       현실에서는 수동적 존재가 소프트웨어 세상에서는 능동적으로 변한다(음료수가 스스로 양조절) -> 더욱 많은 특징과 능력보유-> 객체지향의 세계는 현실의 추상화가 아니다.
## 3장 타입과 추상화
### 추상화는 현실에서 출발하되 불필요한 부분을 도려내어 복잡성을 줄이고 본질을 드러내는 과정.
추상화는 "목적"에 의존적이다. 현상은 복잡 법칙은 단순하니 버릴게 무엇인지 알아내라
### 객체지향과 추상화
구체적인 사물간의 차이점을 무시하고 공통점만을 취해 특정개념으로 단순화하는 것은 추상화의 일종이다. 이후 남은 공통점에서 불필요한 세부 사항은 제거
  많은 객체중 특정 특징을 가지고 있는 객체만을 특정 "개념(트럼프)"으로 추상화.그리고 개념에 속한 객체를 개념의 인스턴스라고 한다. 개념에 따라 우리는 객체들을 분류한다.
### 타입
- [ ] 타입은 개념이다
1. 타입은 데이터가 어떻게 사용되느냐에 관한 것이다(숫자형 데이터는 사칙연산, 문자열은 합쳐문자열을 만들거나 문자의 길이를 알 수 있음)
  즉 데이터가 어떤 타입에 속하는지 결정하는 것은 데이터에 적용할 수 있는 작업(연산자)
2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 개발자는 단순히 데이터 타입에 적용할 수 있는 연산자만 알고 있으면 된다.
- [ ] 객체와 타입
1. 실제로 프로그래밍을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다.
2. 그렇다면 객체는 데이터인가? 그렇지 않다. 객체에서 중요한 것은 "상태"가 아닌 행동이다.객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야할 지 결정하는 것이 중요하다
.데이터 타입은 객체의 타입과도 동일하게 적용된다.  
첫째, 어떤 객체가 어떤 타입에 속하는지 결정하는 것은 객체가 수행하는 행동이다. 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.  
둘쨰, 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다  
여기서 우리는 중요한 원칙을 이끌어낼 수 있다. 바로 " 행동이 우선이다" 라는 것이다.
첫번째에 따르면 어떤 행동을 하느냐에 따라 객체의 타입이 결정된다. 두번째에 따르면 객체의 타입은 객체의 내부 표현과는 아무 상관이 없다. 따라서 
* 내부 표현이 다르더라도 어떤 객체가 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다. 동일한 책임을 수행하는 객체는 동일한 타입에 속한다고 할 수 있다.  
* 내부의 표현이 달라도 동일하나 메시지를 수신하고 이를 처리한다면 같은 타입이다. 하지만 표현 방식이 다르다면 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.
* 이것은 "다형성"에 의미를 부여한다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력이다.  
* 또한 내부 표현방식과 무관하게 행동만이 고려 대상이라는 사실은, 행동만을 보여주고 데이터를 감춰야한다. 이 원칙을 흔히 캡슐화라고 한다. 
즉 행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야하는 데이터가 아니라 객체가 외부에 제공하야 하는 행동을 먼저 생각해야한다.   
그렇다면 책임을 먼저 결정하고 이후에 데이터를 결정한 후 데이터를 외부 인터페이스 뒤로 캡슐화해야한다. 이것이 바로 "책임-주도-설계"이다.
### 타입의 계층
1. 슈퍼타입과 서브 타입또한 두 타입간의 관계가 행동에 의해 결정된다는 것을 알아야한다. 즉 특정 타입이 다른 타입의 서브 타입이 되기 위해서는 행위적 호환성을 만족시켜야한다.  
ex) 트럼프인간은 트럼프를 대체할 수 있어야한다. 
### 정적 모델
- [ ] 타입의 목적  
왜 타입을 사용해야할까? 사용하는 이유는 인간의 인지능력으로는 객체의 복잡성을 극복하기가 너무 어렵기 떄문이다.  
타입은 시간에 따라 동적으로 변하는 엘리스의 상태를 시관과 무관한 정적인 모습으로 다룰 수 있게해준다.
-[ ] 그렇기에 결국 타입은 추상화다.  
어떤 시점에 엘리스에 관해 생각할 때 불필요한 시간과 상태변화라는 요소를 제거하고 철저하게 정적인 관점에서 엘리스의 모습을 묘사하는 것을 가능케해준다.  
타입은 추상화이기 때문에 타입을 이요한다면 객체의 동적인 특성을 추상화 할 수 있다.  
-[ ] 클래스  
객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 타입을 구현하는 가장 보편적인 방법은 클래스라는 것이다. "타입을 구현한다"에 주의해야한다  
클래스와 타입은 동일한 것이 아니다! 타입은 객체를 분류하기 위해 사용되는 개념이다. 클래스는 타입을 구현할 수 있는 메커니즘 중 하나일 뿐이다. (자바 스크립트에 클래스가 존재하지 않음)  
하지만 객체지향 패러다임을 주도하는 대부분의 프로그래밍 언어는 클래스를 기반으로 하기 때문에 대부분의 사람들은 클래스와 타입을 동일한 개념이라고 생각한다.  
클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 구분하여야한다. 
